import torch
import torch.nn as nn
import torchvision
import torchvision.transforms as transforms

# 模型定义部分，包括结构和前向传播过程
class LeNet5(nn.Module):
    def __init__(self, num_classes):
        super(LeNet5, self).__init__()
        # 卷积层，下同
        self.layer1 = nn.Sequential(
            nn.Conv2d(1, 6, kernel_size=5, stride=1, padding=0),
            nn.BatchNorm2d(6),		# 更现代化的批量归一化
            nn.ReLU(),)
        # 下采样（最大池化），下同
        self.subsampel1 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        
        self.layer2 = nn.Sequential(
            nn.Conv2d(6, 16, kernel_size=5, stride=1, padding=0),
            nn.BatchNorm2d(16),
            nn.ReLU(),)
        
        self.subsampel2 = nn.MaxPool2d(kernel_size = 2, stride = 2)
        # 全连接
        self.L1 = nn.Linear(400, 120)
        self.relu = nn.ReLU()
        self.L2 = nn.Linear(120, 84)
        self.relu1 = nn.ReLU()
        self.L3 = nn.Linear(84, num_classes)
    # 前向传播
    def forward(self, x):
        out = self.layer1(x)
        out = self.subsampel1(out)
        out = self.layer2(out)
        out = self.subsampel2(out)
        # 将上一步输出的16个5×5特征图中的400个像素展平成一维向量，以便下一步全连接
        out = out.reshape(out.size(0), -1)
        # 全连接
        out = self.L1(out)
        out = self.relu(out)
        out = self.L2(out)
        out = self.relu1(out)
        out = self.L3(out)
        return out

# 加载训练集
train_dataset = torchvision.datasets.MNIST(root = './data',
                                           train = True,
                                           transform = transforms.Compose([
                                                  transforms.Resize((32,32)),
                                                  transforms.ToTensor(),
                                                  transforms.Normalize(mean = (0.1307,), 
												                     std = (0.3081,))]), # 重设大小，转为张量，归一化，参数是测试出来的
                                           download = True)
 
# 加载测试集
test_dataset = torchvision.datasets.MNIST(root = './data',
                                          train = False,
                                          transform = transforms.Compose([
                                                  transforms.Resize((32,32)),
                                                  transforms.ToTensor(),
                                                  transforms.Normalize(mean = (0.1325,), 
												                     std = (0.3105,))]),
                                          download=True)

batch_size = 64
# 加载训练数据
train_loader = torch.utils.data.DataLoader(dataset = train_dataset,
                                           batch_size = batch_size,
                                           shuffle = True)
# 加载测试数据
test_loader = torch.utils.data.DataLoader(dataset = test_dataset,
                                           batch_size = batch_size,
                                           shuffle = False)	

# 训练集打乱而测试集不打乱，降低过拟合，提高效率

num_classes = 10
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model = LeNet5(num_classes).to(device)
cost = nn.CrossEntropyLoss()
learning_rate = 0.001
optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)
total_step = len(train_loader)
num_epochs = 10 #遍历测试集轮次

# 定义训练流程
for epoch in range(num_epochs):
    for i, (images, labels) in enumerate(train_loader):  
        images = images.to(device)
        labels = labels.to(device)
 
        # 前向传播
        outputs = model(images)
        loss = cost(outputs, labels)
 
        # 反向传播
        optimizer.zero_grad()	# 清零梯度，避免累计
        loss.backward()		# 反向传播
        optimizer.step()	# 更新模型参数
 
        # 定期输出训练信息
        if (i+1) % 400 == 0:
            print ('Epoch [{}/{}], Step [{}/{}], Loss: {:.4f}' 
        		           .format(epoch+1, num_epochs, i+1, total_step, loss.item()))

with torch.no_grad():
    
    correct = 0		# 正确分类的样本数
    total = 0		# 总样本数
 
    for images, labels in test_loader:
        images = images.to(device)
        labels = labels.to(device)
 
        # 模型预测
        outputs = model(images)
 
        # 计算准确率
        # 从模型输出中获取每个样本预测的类别
        _, predicted = torch.max(outputs.data, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()
 
    # 输出准确率
    print('Accuracy of the network on the 10000 test images: {} %'.format(100 * correct / total))
    
